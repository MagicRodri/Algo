 One of the most valuable skills to have is a full stack web developer is without a doubt Node.js And that's not going to change anytime soon But you might be wondering why I'm making a node tutorial in 2020 because if you've been watching the news You may have heard that node was killed last week by Denno When I lay my fingers upon me making the extremely chaotic JavaScript world even more complicated If you're just starting to learn JavaScript this can be very confusing and you might be wondering should I learn node or Denno? The answer is node, especially if you want to get a job or build a product When something becomes as established as node, it doesn't get replaced You'll see things like this happen all the time A few years ago everybody was saying GraphQL would replace REST And 10 years ago people were saying node.js would replace PHP These predictions never pan out and are just built on top of hype That being said, I do think Denno is awesome and has a bright future Both both both both is good And if you learn node today those skills will mostly transfer to Denno tomorrow In today's video you'll learn the basics of node.js and 7 easy steps Then we'll put those steps together to build a full stack web application Because in my opinion the best way to learn how to code is to build something meaningful from scratch By the end of the video will deploy our code to the cloud so you can show off your API to your friends and family If you're new here like and subscribe and head over to FireShipIO to follow along with the full write up to this video Step 1 is to understand what node.js is and why you would want to use it Node.js itself is not a programming language but rather a runtime that allows you to run JavaScript on a server You see when JavaScript first came around in the 1990s it was designed as a simple scripting language to run in the browser As the web platform evolved, JavaScript became more and more powerful and in 2009 we saw the initial release of node.js Now up until this time it was impossible to write JavaScript code on the server Most servers were written in languages like Java or PHP It revolutionized web development because now a web developer could write a full stack application in a single language So that's all node.js is it's a way for developers to write JavaScript on the server when it could previously only be written in a web browser Now there are a lot of low-level implementation details here that you don't need to know about as a beginner But if you really want to dive into how node.js works check out my how it's made video But what kind of problems can node.js actually solve? Node.js can do a lot so instead of listing out a bunch of use cases I'll show you how to build a full stack web application from scratch This is how it'll work You visit a URL on the internet that points to your server When the request is received we can use node to handle the request and read a file from the server's file system And then respond back to the client so they can view the HTML in the browser Step 2 how to install node.js Node can be installed on windows macro linux and is probably already installed on your system In this tutorial I'll be using Ubuntu via the windows subsystem for linux At this point I've just opened up an empty directory in VS code and then pulled up a terminal session You can find out if node is installed on your system by running node flag V from the command line As you can see here I'm running version 12.16 which is the current long term support version If you get an error at this point it means that you don't have node installed And even if you do have node installed it'd be a very good idea to use a package called node version manager To manage the installation of different node versions on your system There's an NVM package for mac and linux or a separate package for windows Go ahead and follow the instructions to install NVM on your system And that will give you the ability to install any version of node.js that you want For example you could run NVM install 12.16.3 then run NVM use to use that specific version as your runtime And now that we have node.js installed we can move on to step 3 Hello world But first if you're serious about node.js consider becoming a pro member at fire ship I.O It'll give you access to my four-length courses almost all of which cover advanced use cases for node.js But we need to walk before we can run. So how do we actually use this thing? One way to mess around with node is in repel mode which stands for read of owl print loop When you type node into the command line it allows you to run JavaScript code and will print out the results For example we can type console log hello world and it will log that value out This is nice for messing around but go ahead and hit control C twice to shut it down Because in most cases we want to execute JavaScript code that lives in an actual file The default entry point into a node.js app is the index.js file Go ahead and create an index.js file manually in VS code Then inside that file add console log hello world You can now run the code inside this file with the node command followed by the path to this file And because it's an index file you can actually just point to the parent directory Congratulations you just built a node app Step 4 understand the node runtime In most ways JavaScript works the same way it does and the browser as it does node.js But there are some very important differences you should know about First node has a handful of built in identifiers One of those globals is console which we've already been using to log out values to the terminal There is another global with a name of global This object is a namespace that is available throughout the entire node process For example if we assigned a lucky number property to global we could then access it anywhere else in our code If you're a front end web developer you can compare global to the window object in the browser Now I think the most important global to be familiar with is process which gives you access to the currently running node process You might use it to check the current platform or operating system which in my case is Linux or grab an environment variable from your server But this gives us a great opportunity to segue into step 5 How do events work in node.js? You'll often hear people describe it as an asynchronous event driven JavaScript runtime The runtime implements a thing called an event loop just like a web browser does And it allows node to push intensive operations off to a separate thread So only very fast non-blocking operations happen on the main thread And this is why people often call node non-blocking It's a design choice that makes node.js very suitable for things that require high throughput Like real-time applications, web servers and things like that So how does that affect me as a coder? Well normally you won't have to think about the low level details You just need to know how events and callbacks work In most cases you'll listen to events Events can come in many forms, but one example is on the process global that we looked at earlier Before a node process finishes, it emits an event named exit We can listen to this event using on and then register a callback function as the second argument When the exit event occurs, node.js will run this function And that's where it gets the name callback Because the function isn't called the first time node.js sees it It's only called after the exit event occurs at some point in the future This event is built into node, but you can also create your own from scratch It will import an event emitter from the events module that is built into node And we'll look at modules in more detail in just a minute We can create a custom event emitter by instantiating the class And then we'll register a callback that fires on the lunch event Now that the callback is registered, you can simply call event emitter emitter with that event name And that triggers your callback function to run As you can see here, we emit the event twice, which will run the callback function twice This event driven style of programming is extremely useful when you have something that is CPU intensive And with that, we can move on to step six, the file system Node has a built in file system module called FS It can read, write, and delete files on the file system, among other things And it can also do things in a blocking or non-blocking way Allow me to explain that by showing you an example First, create a file on the file system called hello.txt And then add whatever text you want inside of it And our JavaScript code will import two functions from the file system module called read file and read file sync Any time you see a function that ends in sync, think blocking Or in other words, it will need to finish all of its work before any of your other code can run We can read a text file on node by simply passing the path to that file And then we'll specify the encoding as UTF-8 Now reading a file might take a while, especially if it's a very large file And what you'll notice here when we run our code is that the second console log won't run until after that file has been read Luckily, you can make your code non-blocking by refactoring this to a callback With read file, we pass the same first two arguments and then add a callback function as the third argument Inside the function, we can access an error object if the operation fails or when successful the actual text from the file The super cool thing about this is that even though the console log to the text file comes first in our script It's not the thing that gets executed first Node registers the callback, executes the rest of the script, and then finally runs the callback when the file has been read So that gives us two different ways to read a file, but there's actually one other way we could go about this And that's using a promise-based solution Promises are also asynchronous and non-blocking, and they tend to produce much cleaner code when compared to callbacks Notice how in this example, we're importing read file from the promises namespace This gives us a function that returns a promise when called If you're using the latest bleeding edge version of node, you could potentially use this function with top level await Which means you can use a wait to resolve the promise here at the top of the script However, since we're currently using node version 12, we'll go ahead and wrap this in an async function And this async await syntax will make your code much easier to read, especially when you have multiple async calls in the same function Okay, so now that you know how to read files, I want to backtrack a little bit and talk about this require function that you've seen me use in the past couple examples Step 7 Modules A module is nothing more than a JavaScript file that exports its code It has a bunch of built-in modules like FS and events that we've already looked at And there's a long list of other modules beyond that The traditional way to import a module and node is to use this require function But a quick side node on that first, because node recently added support for ES modules Which use the import exports syntax Most node.js code out there written in vanilla JavaScript still uses require So it's very important for you to know as a node.js developer And if all that's confusing to you, well, all I can say is welcome to the JavaScript world Let's look at how we can use modules in our own code base Create a new file to serve as your module Then go into your index.js file, create a variable for the module, and then import it using require When you console log it, you'll notice that it's currently just an empty object In order to make a module useful, you need to export some code from it In the module's file, you can reference this object with module.xports You can add new properties to the object or redefine it as a new object In either case, whatever you add here will now be available to use in the other file And as you can see, the object is no longer empty when we console log it But at some point, you'll very likely want to use somebody else's code out there in the world And the primary place to do that is via node package manager or npm Which was recently acquired by GitHub, which itself was recently acquired by Microsoft When you installed node earlier in the video, it also installed npm Which is a tool you can use to install remote packages to use in your own code The first step we'll want to take is to open the command line and run npm init We'll use the white flag to use the default options And what you'll notice is that it creates a package JSON file here in the root of the application This file can contain metadata about your project, but most importantly, it keeps track of the dependencies that you use here At this point, we haven't installed anything yet So let's go ahead and change that by opening the command line again and running npm install express Express is a minimal web application framework and one of the most popular third-party node modules After running the command, you'll notice a few things happened here In the package JSON file, it added express to the dependencies and pegged it to a specific version This dependencies object allows you to manage multiple dependencies in a project And then reinstall them all at once on a different system Now the actual raw source code for the dependency lives in this node modules directory You should never have to modify code in the node modules directory If you find yourself writing code in here, you're probably doing it wrong That's because the package JSON controls how this directory is built It fetches your remote packages, saves the source code here, and that process should be able to be repeated on any system Now that we have this package installed, we can import it by name in our JavaScript code In this case, we simply require express And now we've reached the point where we're ready to put these seven steps together to build a real full stack application and deploy it to the cloud What we're building here is actually just your typical full stack web application Our server will live on a URL and when a user makes a request to this URL in the browser, the server will respond with some HTML And our code will first create an instance of an express app An express app allows us to create different URLs and endpoints that a user can navigate to in the browser And then we define code for the server to handle those requests Now I don't want to get too deep into HTTP, but when the user navigates to a URL in the browser, it's what's known as a Git request Which means they're requesting some data on the server and not trying to modify or update anything on the server With express, we can set up an endpoint like that by calling app.get And in the first argument is the URL that the user will navigate to In this case, we'll just use a forward slash for the root URL But feel free to create multiple pages for your web app by creating different URLs The second argument here is our callback function You can think of every request to this URL as an event And then you handle that event with this function And express gives us two parameters to make use of, the request and the response The request is the incoming data from the user In this example, we don't really need to parse any data from the request However, in many cases you might want to look at the headers or the body of the request To authenticate a user or understand what the user is trying to do At this point, we need to implement the code to handle the request What we want to do is read some HTML from our file system And then send it back down to the browser As you can see here, I'm creating a file called home.html with just some generic HTML markup inside In our source code, we can then import read file from nodes file system module Just like we did earlier, we'll read the file, use utf8 encoding Then in our callback function here, we'll have access to the HTML string And we can send a response back down to the client by calling response.send And also, if there's an error in the callback, we can handle that by sending a response with a status code of 500, which means a server error So the user knows that something went wrong on the server And that's all there is to it. We now have a way to send HTML from the server to the client Now we just need to tell our express app to start listening to incoming requests We do that by defining a port, which will normally come from a node environment variable Then we call app.listen with that port And when it starts up, we'll console log that the app is available on localhost 3000 You can start it up by opening the command line and running node with the current working directory If you go ahead and open it in the browser, you should see your HTML return back to you Now there is one important thing you should know at this point And that's that callbacks can be very difficult to work with, especially as your app grows in complexity It often leads to a state known as callback hell, where you have a bunch of callbacks nested within callbacks, within more callbacks, and so on A great way to avoid code like this is to use promises instead of callbacks, and that's very easy to do in node.js Instead of importing read file from fs, we'll import it from fs.promises We can make our callback function async, and then we can write the response in a single line of code by saying response send And then await the operation to read file That's much more concise and readable, but it's especially useful when you have multiple async operations to handle in a single request So now that we've built a node.js app, how do we deploy it to the cloud so people can actually use it There's a bunch of different ways we could do it, but an easy and freeway is with Google App Engine App Engine has what's known as a standard environment for node.js up to version 12 And what that does is provide you with a server in the cloud that scales automatically based on the incoming traffic to your app It's incredibly easy to set up, but you first need to have a Google Cloud platform account And also the Google Cloud command line tools installed on your local system Once you have that done, you can simply go into your source code and create an app.yaml file This file is used to configure your cloud server. The only thing we need at this point is to specify a runtime of node.js version 12 App Engine will run your code by looking in the package JSON file for a start script So let's go in there and define a start script that runs node in the current working directory to start our express app From there, we can simply open the command line and run gcloud app deploy That'll take a minute, and then it will give you a URL where you can access your app publicly on the web Congratulations, you're now a full stack cloud architect If this video helped you, please like and subscribe And if you really want to dive deep into node.js and express, consider becoming a pro member at FireShip.io I have a whole bunch of advanced content covering real world use cases with these technologies Thanks for watching, and I will see you in the next one Bye!